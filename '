import { routeActions } from 'react-router-redux';
import { take, race, call, put, fork, select } from 'redux-saga/effects';
import { wrapObservable } from '../utils/wrap_observable';
import { CREATE_APP, UPDATE_APP, DELETE_APP, WATCH_APPS, UNWATCH_APPS } from '../actions/index';
import { Theron, ROW_ADDED, ROW_CHANGED, ROW_REMOVED } from '../../../lib/driver/driver';

function* watchCreate() {
  while (true) {
    const { payload, resolve, reject } = yield take(CREATE_APP);
    const { api } = yield select(state => state.auth);

    try {
      const { id } = yield api.createApp(payload);

      resolve();
      yield put(routeActions.push(`/apps/${id}`));
    } catch(error) {
      typeof error.message === 'object' ? reject(error.message) : reject({ _error: error.message });
    }
  }
}

//function* watchCreate() {
//  while (true) {
//    const { payload, resolve, reject } = yield take(CREATE_APP);
//    const { api } = yield select(state => state.auth);
//
//    try {
//      //const { id } = yield api.createApp(payload);
//
//
//      // yield take('APPS:' + ROW_ADDED);
//
//      //'APPS:' + ROW_ADDED)jw
//      //
//      //yield api.createApp(payload).then(({ id }) => take('APPS:' + ROW_ADDED));
//
//      //const [{ id }, action] = yield [request,
//      //  take(action => {
//      //    console.log(id);
//      //    return action.type === 'APPS:' + ROW_ADDED && action.payload.row.id === id;
//      //  })
//      //];
//
//      const request = api.createApp(payload);
//
//      yield take(function* (action) {
//        yield request;
//        console.log();
//        return false;
//        //return action.type === 'APPS:' + ROW_ADDED && action.payload.row.id === id;
//      })
//
//      resolve();
//      //yield put(routeActions.push(`/apps/${id}`));
//
//    } catch(error) {
//      typeof error.message === 'object' ? reject(error.message) : reject({ _error: error.message });
//    }
//  }
//}

function* watchUpdate() {
  while (true) {
    const { id, payload, resolve, reject } = yield take(UPDATE_APP);
    const { auth: { api } } = yield select();

    try {
      const [action] = yield [
        take(action => action.query === 'APPS' && action.type === ROW_CHANGED && action.payload.row.id === id), api.updateApp(id, payload)
      ];

      resolve();
    } catch(error) {
      typeof error.message === 'object' ? reject(error.message) : reject({ _error: error.message });
    }
  }
}

function* watchDelete() {
  while (true) {
    const { id } = yield take(DELETE_APP);
    const { auth: { api } } = yield select();

    try {
      const [{ payload: { prevRowId } }] = yield [
        take(action => action.query === 'APPS' && action.type === ROW_REMOVED && action.payload.row.id === id), api.deleteApp(id)
      ];

      const { apps } = yield select();

      if (prevRowId) {
        const nextRowId = apps.rows[apps.rows.findIndex(row => row.id === prevRowId) + 1];
        console.log(nextRowId);

        yield put(routeActions.push(`/apps/${nextRowId || prevRowId}`));
      } else {
        console.log('---------');
        console.log(apps.rows);
        yield put(routeActions.push(apps.rows.length === 0 ? '/apps/new' : `/apps/${apps.rows[0]}`));
      }
    } catch(error) {
      console.log(error);
    }
  }
}

function* streamApps() {
  while (true) {
    yield take(WATCH_APPS);

    const { theron } = yield select();

    for (let next of wrapObservable(theron.ref.watch('/api/apps', { orderBy: 'name'}))) {
      const { action } = yield race({ action: next, overwise: take(UNWATCH_APPS) });

      if (action) {
//        console.log(Object.assign({}, action, { query: 'APPS' }));
        yield put(Object.assign({}, action, { query: 'APPS' }));

      } else {
        break;
      }
    }
  }
}

export function* appsFlow() {
  yield [
    fork(watchCreate),
    fork(watchUpdate),
    fork(watchDelete),
    fork(streamApps),
  ]
}

